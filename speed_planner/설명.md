# Simple Speed Planner — 설계 & 사용 안내 (ROS 2 Humble)

본 문서는 우리가 논의하고 구현한 **로컬 경로 기반 속도 플래닝**과 **하드웨어 제어용 단일 목표 속도 생성**을 정리한 자료입니다.  
구성 파일, 노드 동작, 알고리즘, 파라미터, 튜닝 포인트, 실행 방법을 한 번에 확인할 수 있게 정리했습니다.

---

## 0) 배경 및 목표

- 기존 파이프라인
  - **좌/우 콘 분류(C++)** → `/left_cone_marker`, `/right_cone_marker`
  - **로컬 경로 생성(Python)**: `reference_path_planning.py`
    - Delaunay 내부선 중점 → B-spline → **등간격(arc_step≈0.5 m)** 샘플
    - `/local_planned_path`(nav_msgs/Path, frame=`base_link`) 발행
    - 시각화: `/final_waypoints`, `/waypoint_speed_bars`
    - 속도 프로파일 수신: **`/desired_speed_profile`** (Float32MultiArray)

- 이번 목표
  1) **로컬 경로**와 **현재 속도**를 기반으로, **웨이포인트별 목표 속도 배열** `/desired_speed_profile`을 만들기
  2) 하드웨어 제어를 위해 순간 **단일 목표 속도** `/desired_speed`를 **고주기(기본 50 Hz)**로 발행하기

---

## 1) 파일 구성

```
src/Planning/speed_planner/
├── config/
│   └── simple_speed_planner.yaml
├── launch/
│   └── simple_speed_planner.launch.py
└── src/
    └── simple_speed_planner.cpp
```

- `simple_speed_planner.yaml`: 토픽/알고리즘 파라미터
- `simple_speed_planner.launch.py`: 노드 런치
- `simple_speed_planner.cpp`: 속도 플래너(프로파일 + 단일 속도 생성)

---

## 2) 인터페이스 (I/O 토픽)

### 입력
- **`/local_planned_path`** (`nav_msgs/Path`) — 등간격 샘플의 로컬 경로 (frame: `base_link`)
- **`/current_speed`** (`std_msgs/Float32`, ~100 Hz) — 실측 차량 속도 (m/s)

### 출력
- **`/desired_speed_profile`** (`std_msgs/Float32MultiArray`) — 웨이포인트별 목표 속도 [N]
- **`/cmd/speed`** (`std_msgs/Float32`) — 하드웨어 제어용 순간 목표 속도 (m/s), 기본 50 Hz

### 주기
- 프로파일 재계산: **`recalc_rate_hz`** (기본 15 Hz)
- 단일 속도 퍼블리시: **`desired_pub_rate_hz`** (기본 50 Hz)

---

## 3) 알고리즘 개요

### 3.1 곡률 계산 (국소 3점 기하)
- 점열 `P[i]=(x_i,y_i)`에서 **3점 외접원 곡률** 근사
- 내부 포인트는 3점, 경계는 이웃값 복사
- **이동평균(윈도우 k)**로 곡률 스파이크 완화  
  → `kappa_ma_window`로 조정

### 3.2 곡률 기반 속도 상한
- 횡가속 제한: `a_y = v^2 |κ| ≤ ay_max`  
  → `v_kappa(i) = sqrt( ay_max / (|κ_i| + ε) )`
- 포인트 속도 상한 `v_lim(i) = min(v_max, v_kappa(i))`

### 3.3 Forward–Backward Pass (시간화)
- **Forward(가속 한계)**:  
  `v[i] ≤ sqrt( v[i-1]^2 + 2 a_acc * ds[i-1] )`
- **Backward(제동 한계)**:  
  `v[i] ≤ sqrt( v[i+1]^2 + 2 a_brk * ds[i] )`
- **종단 조건**: 마지막 점 `v_end` 적용 후 Backward 전파
- 결과: **웨이포인트별 목표 속도** `v[i]`  
  → `/desired_speed_profile`로 발행 (길이=N)

> 주의: Path 포인트 수(N)가 프레임마다 달라도, **항상 같은 길이**로 프로파일을 발행하여 `reference_path_planning.py`가 1:1로 시각화할 수 있게 함.

### 3.4 단일 목표 속도 `/cmd/speed` (프리뷰 기반)
- 현재 필터된 속도 `v_cur`로 **프리뷰 거리** 산출:  
  `s_cmd = clamp( preview_s_min + preview_t * v_cur, preview_s_min, preview_s_max )`
- 누적거리 배열 `s[i]`에서 **`s_cmd` 이상**인 최소 인덱스 `i_cmd` 탐색
- 인덱스 보간(선형)으로 `v_raw` 추출
- **레이트 제한**: `|Δv_cmd/Δt| ≤ cmd_acc_limit`
- **EMA 스무딩**: `τ = ema_tau_cmd`
- 최종 **`/cmd/speed`**를 **50 Hz**로 퍼블리시

---

## 4) 파라미터 (YAML 발췌)

```yaml
# Topic
path_topic: "/local_planned_path"
speed_topic: "/current_speed"
out_topic: "/desired_speed_profile"
desired_speed_topic: "/desired_speed"

# 주기 & 호라이즌
recalc_rate_hz: 15.0
desired_pub_rate_hz: 50.0
horizon_m: -1.0         # >0이면 앞쪽 거리만 사용(예: 40.0)

# 속도/가속 제약
v_max: 4.0
v_min: 0.3
v_end: 0.0
a_acc: 2.0
a_brk: 2.5
ay_max: 1.5
epsilon_kappa: 1.0e-6

# 곡률 스무딩
kappa_ma_window: 5

# 속도 필터(입력)
ema_tau_speed: 0.2      # s

# 단일 속도 생성(프리뷰 & 스무딩)
preview_t: 0.4          # s
preview_s_min: 0.5      # m
preview_s_max: 5.0      # m
cmd_acc_limit: 1.5      # m/s^2
ema_tau_cmd: 0.2        # s
```

> 권장 초기값:  
> `ay_max=1.5`, `a_acc=2.0`, `a_brk=2.5`, `v_end=0.0`, `preview_t=0.4`, `cmd_acc_limit=1.5`

---

## 5) 구현 노트

- Path는 기본 **등간격(≈0.5 m)** → `ds`를 개별 계산해 사용(끝단 짧은 구간 대응)
- **호라이즌 제한**(`horizon_m`)으로 계산량/안정성 조절 (예: 40 m ≈ 80 포인트)
- `/current_speed`는 **EMA(τ≈0.2s)**로 노이즈만 줄여 사용
- 프로파일 길이와 Path 길이를 **항상 동일**하게 유지
- `/desired_speed`는 프로파일 유효할 때만 산출(프로파일 유실 시 마지막 값 유지 전략은 선택사항)

---

## 6) 빌드 & 실행

### CMakeLists.txt (요지)
```cmake
add_executable(simple_speed_planner src/simple_speed_planner.cpp)
ament_target_dependencies(simple_speed_planner rclcpp std_msgs nav_msgs)
install(TARGETS simple_speed_planner DESTINATION lib/${PROJECT_NAME})
install(DIRECTORY config launch DESTINATION share/${PROJECT_NAME})
```

### package.xml (요지)
```xml
<depend>rclcpp</depend>
<depend>std_msgs</depend>
<depend>nav_msgs</depend>
```

### 실행
```bash
ros2 launch speed_planner simple_speed_planner.launch.py
```

### 확인
```bash
ros2 topic echo /desired_speed
ros2 topic hz   /desired_speed
ros2 topic echo /desired_speed_profile
```

---

## 7) 튜닝 가이드

- **코너 감속 부족** → `ay_max` ↓
- **가속/제동 과격** → `a_acc`/`a_brk` ↓, `cmd_acc_limit` ↓
- **목표 속도 지터** → `kappa_ma_window` ↑, `ema_tau_cmd` ↑, 프리뷰 `preview_t` ↑
- **응답이 굼뜸** → `preview_t` ↓, `ema_tau_cmd` ↓ (단 레이트 제한은 안전 범위 유지)

---

## 8) 디버깅 팁

- 프로파일 N, v0, vend 로그: `log_throttle_sec`로 간격 조정
- RViz: `/final_waypoints`(자홍 구체)와 `/waypoint_speed_bars`(자홍 막대)가 커브에서 낮아지는지 관찰
- `ros2 topic hz`로 `/desired_speed` 퍼블리시 주기 확인

---

## 9) 주의점

**Q. 스피드 프로파일의 [0]이 현재 속도인가요?**  
A. 측정값과 같지는 않습니다. [0]은 **현재 위치에서의 “원하는 속도”**로, 곡률/제약/종단 조건이 반영됩니다.

**Q. 하드웨어에게 어떤 값을 주나요?**  
A. 하드웨어 제어에는 **스칼라 목표 속도 `desired_speed`(m/s)** 를 **주기적으로(권장 50–100 Hz)** 구독합니다. 값은 아래 규칙으로 `/desired_speed_profile`에서 **프리뷰 기반**으로 뽑아 만든 것입니다.

- **입력**:  
  - `v[i]` = `/desired_speed_profile`의 i번째 속도 (웨이포인트별 목표 속도)  
  - `s[i]` = `/local_planned_path`의 누적거리(0에서 시작, 등간격이므로 i↔거리 1:1)  
  - `v_cur` = `/current_speed`의 EMA 필터값(τ≈0.2 s)

- **프리뷰 거리 계산**:  
  `s_cmd = clamp(preview_s_min + preview_t * v_cur, preview_s_min, preview_s_max)`  
  예) `preview_t=0.4 s`, `preview_s_min=0.5 m`, `preview_s_max=5.0 m`

- **인덱스 선택 & 보간**:  
  `j = lower_bound(s >= s_cmd)` (없으면 `j=N-1`)  
  보간계수 `w = (s_cmd - s[j-1]) / (s[j] - s[j-1])` (경계 처리 포함)  
  `v_raw = (1-w) * v[j-1] + w * v[j]`  (j=0이면 `v_raw=v[0]`, j=N이면 `v_raw=v[N-1]`)

- **레이트 제한(가속도 한계 반영)**:  
  `v_lim = v_prev + clamp(v_raw - v_prev, -a_lim*dt, +a_lim*dt)`  
  권장: `a_lim = 1.2 ~ 1.8 m/s²`

- **EMA 스무딩(선택)**:  
  `α = exp(-dt / τ_cmd)`, `v_cmd = α * v_prev + (1-α) * v_lim`  
  권장: `τ_cmd = 0.15 ~ 0.25 s`

- **클리핑 & 퍼블리시**:  
  `v_cmd = clip(v_min, v_cmd, v_max)` → `/desired_speed` (Float32, m/s)로 발행

- **실전 팁**:  
  1) **저속/정지 근처**에서는 `s_cmd`가 너무 작지 않게 `preview_s_min ≥ 0.5~1.0 m` 유지  
  2) **급커브 접근**에서 더 선제 감속을 원하면 `preview_t`를 소폭 ↑(0.45~0.5 s)  
  3) **지터**가 보이면 `τ_cmd`↑ 또는 `a_lim`↓  
  4) 프로파일/경로 **유실 시** 마지막 `v_cmd`를 짧게 유지하거나 `min(v_cur, v_safe)`(예: 1.0 m/s)로 폴백

- **짧은 예시**(등간격 0.5 m, `preview_t=0.4 s`, `preview_s_min=0.5 m`):  
  `v_cur=2.5 m/s` → `s_cmd=0.5+0.4*2.5=1.5 m` → `j≈ceil(1.5/0.5)=3` → `v_raw≈v[3]`  
  레이트 제한·EMA를 거쳐 `/desired_speed`로 퍼블리시.


**Q. 경로 길이가 프레임마다 달라도 괜찮나요?**  
A. O. 국소 곡률/Forward–Backward는 등간격 샘플에 국소적이라 견고합니다. 프로파일 길이를 항상 Path와 맞춰 발행합니다.

---

## 10) 향후 확장

- 정지선/장애물 인지 시 강제 `v=0` 구간 삽입
- 앞차 추종(헤드웨이/거리 제약) 추가
- 路面 마찰(μ) 추정 반영하여 `ay_max` 동적 조정
- 저크 제한(시간 매개화 기반 스무딩) 정교화

---

**문의/변경**: 파라미터는 YAML로 모두 노출되어 있어 런타임 튜닝이 쉽습니다.  
우선 기본값으로 시작 → 코너/응답/지터에 맞춰 `ay_max`, `a_acc/a_brk`, `preview_t`, `cmd_acc_limit`, `ema_tau_cmd`를 조정해 보세요.